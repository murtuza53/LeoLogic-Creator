
// DO NOT EDIT, this file is generated by Firebase Studio
'use server';
import { initializeApp, getApps, getApp, App } from 'firebase-admin/app';
import { getFirestore, increment } from 'firebase-admin/firestore';

// Note: This file is now using the Firebase Admin SDK as it's a server-side file.
// Client-side Firebase logic is handled in src/firebase/index.ts

let app: App;
if (!getApps().length) {
  app = initializeApp();
} else {
  app = getApp();
}

const db = getFirestore(app);

const COUNTERS_COLLECTION = 'generationCounters';
const COUNTERS_DOC_ID = 'featureCounts';
const CONTACTS_COLLECTION = 'contacts';
const USERS_COLLECTION = 'users';


export type Feature = 'smartProduct' | 'aiMath' | 'qrGenerator' | 'ocr' | 'mergePdf' | 'imageExcel' | 'imageToWebp' | 'imgRemoveBg' | 'imgChangeBg' | 'resizeCropImage' | 'logoMaker' | 'pdfCompress' | 'benefitPay' | 'bmiCalculator' | 'fitnessMentor' | 'splitPdf' | 'bmrCalculator' | 'weightLoss' | 'scientificCalculator' | 'unitConverter';

export type ContactMessage = {
  name: string;
  email: string;
  subject?: string;
  message: string;
};

export type UserProfile = {
  name: string;
  email: string;
};

export async function createUserProfile(userId: string, data: UserProfile): Promise<void> {
  try {
    const userRef = db.collection(USERS_COLLECTION).doc(userId);
    await userRef.set({
      ...data,
      createdAt: new Date(),
    });
  } catch (error) {
    console.error('Failed to create user profile:', error);
    throw new Error('Failed to create user profile.');
  }
}

export async function saveContactMessage(message: ContactMessage): Promise<void> {
  try {
    await db.collection(CONTACTS_COLLECTION).add({
      ...message,
      createdAt: new Date(),
    });
  } catch (error) {
    console.error('Failed to save contact message:', error);
    throw new Error('Failed to save contact message.');
  }
}

export async function incrementCount(feature: Feature): Promise<void> {
  try {
    const counterRef = db.collection(COUNTERS_COLLECTION).doc(COUNTERS_DOC_ID);
    
    const payload: { [key: string]: any } = {};
    payload[feature] = increment(1);

    await counterRef.set(payload, { merge: true });

  } catch (error) {
    console.error(`Failed to increment count for ${feature}:`, error);
    throw new Error(`Failed to increment count for ${feature}.`);
  }
}

export async function getFeatureCountsFromDb(): Promise<Record<Feature, number>> {
    const initialCounts: Record<Feature, number> = {
        smartProduct: 0,
        aiMath: 0,
        benefitPay: 0,
        qrGenerator: 0,
        ocr: 0,
        mergePdf: 0,
        imageExcel: 0,
        imageToWebp: 0,
        imgRemoveBg: 0,
        imgChangeBg: 0,
        resizeCropImage: 0,
        logoMaker: 0,
        pdfCompress: 0,
        bmiCalculator: 0,
        bmrCalculator: 0,
        fitnessMentor: 0,
        splitPdf: 0,
        weightLoss: 0,
        scientificCalculator: 0,
        unitConverter: 0,
    };

    try {
        const counterRef = db.collection(COUNTERS_COLLECTION).doc(COUNTERS_DOC_ID);
        const docSnap = await counterRef.get();

        if (docSnap.exists) {
            const data = docSnap.data();
            const counts: Record<Feature, number> = {
                ...initialCounts,
                ...data
            };
            return counts;
        } else {
            // If the document doesn't exist, create it with initial values
            await counterRef.set(initialCounts);
            return initialCounts;
        }
    } catch (error) {
        console.error("Error fetching feature counts:", error);
        // On error, return the initial zeroed counts to avoid breaking the UI
        return initialCounts;
    }
}
